#! /usr/bin/env bash

#  __  __                        _
# |  \/  |                      | |
# | \  / | __ _ _ __  _   _  ___| |
# | |\/| |/ _` | '_ \| | | |/ _ \ |
# | |  | | (_| | | | | |_| |  __/ |
# |_|  |_|\__,_|_| |_|\__,_|\___|_|

# Usage: manuel [task]


# -- # -- # -- # -- # -- # -- # -- #
# Globals
# -- #
MANUEL_VERSION="0.1.0"
if [[ -z $MANUEL_PLUGIN_DIR ]]; then
  MANUEL_PLUGIN_DIR=$HOME/.manuel.d/plugins
fi

# -- # -- # -- # -- # -- # -- # -- #
# Utility functions
# -- #
function _manuel_usage {
  cat <<EOF
  __  __                        _
 |  \/  |                      | |
 | \  / | __ _ _ __  _   _  ___| |
 | |\/| |/ _\` | '_ \| | | |/ _ \ |
 | |  | | (_| | | | | |_| |  __/ |
 |_|  |_|\__,_|_| |_|\__,_|\___|_|

  Version: $MANUEL_VERSION
  Usage: manuel [task] [params]
EOF
  exit 1
}

# bootstrap required file and folders for manuel
function _bootstrap {
  if [[ ! -d $MANUEL_PLUGIN_DIR ]]; then
    echo ">> Initializing plugin directory $plugin_dir"
    mkdir -p $MANUEL_PLUGIN_DIR
    if [[ $? != "0" ]]; then
      echo ">> Could not create plugin directory $plugin_dir, exiting"
      exit 1
    fi
  fi
}


# -- # -- # -- # -- # -- # -- # -- #
# Built-in tasks
# -- #
function load_plugin {
  plugin_name=$1

  if [[ -z $plugin_name ]]; then
    echo ">> Warning: load_plugin called with no argument"
    return
  fi

  plugin_file=$(
    find $MANUEL_PLUGIN_DIR -type f -name "$plugin_name.manuel" | head -1
  )

  if [[ -z $plugin_file ]]; then
    echo ">> Warning: plugin $plugin_name not found in $MANUEL_PLUGIN_DIR"
  else
    source $plugin_file
  fi
}

function list {
  tasks=($(declare -F))
  for t in ${tasks[@]}
  do
    if !( [[ $t == "declare" ]] || \
          [[ $t == "-f" ]] || \
          [[ "$t" =~ ^_(.*) ]]
      ); then
      echo $t
    fi
  done
}

function init {
  if [[ -f manuelfile ]]; then
    echo ">> manuelfile already exists, nothing to do"
    exit 0
  else
    echo ">> Creating new manuelfile in `pwd`"
    echo '#! /usr/bin/env bash

# run this task with: $ manuel hello
function hello {
  echo ">> Hello from manuel!"
}
' >> manuelfile
    exit 0
  fi
}

function manuel_watch {
  target_dir=`readlink -f $1` # a directory to watch for changes in
  actions=$2          # associative array of regex=>command

  # keep track of the last thing to happen so we
  # can skip processing if a CREATE is followed by an ATTRIB, etc
  last_directory=""
  last_target=""
  last_action=""

  echo -e ">> Watching $target_directory"

  # set up watches
  inotifywait -mrq $target_dir \
    --event=CREATE,MOVE,DELETE,ATTRIB | while read LINE
  do
    IFS=' ' read -a event <<< "$LINE"

    directory=${event[0]}
    action=${event[1]}
    target=${event[2]}

    # TODO: this should also handle move_to and move_from
    if ! ( [[ $target == $last_target ]] && \
           [[ $action == "ATTRIB" ]] && \
           [[ $last_action == "CREATE" ]] )
    then
      # check if the event target matches any patterns in actions map
      for k in ${!actions[@]}
      do
        v=${actions[$k]}
        # test the key is a regex match against the target file
        if [[ $target =~ $k ]]; then
          echo -e "\n>> Change event $action detected for $target ..."
          eval $v
        fi
      done
    fi
    last_directory=$directory
    last_target=$target
    last_action=$action
  done
}


# -- # -- # -- # -- # -- # -- # -- #
# Main function
# -- #
function _manuel_main {

  if [[ $# = 0 ]]; then
    _manuel_usage
  fi

  if [[ "$1" == "init" ]]; then
    init
  fi

  _bootstrap

  if [[ -f manuelfile ]]; then
    source manuelfile
    eval $@
    exit 0
  else
    echo -e "No manuelfile found, exiting"
    exit 1
  fi

  exit 0
}


# execute main function
_manuel_main $@
